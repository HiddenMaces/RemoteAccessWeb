# This map block ensures WebSocket connections (Upgrade header) are handled correctly.
# It must be placed outside the 'server' block.
map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}
server {
    listen 80;
    server_name _;

    # Redirect all traffic to HTTPS
    return 301 https://$host$request_uri;
}
server {
    listen 443 ssl;
    server_name fqdn;
    server_name fqdn1; # optional, should be the same as the fqdn in the certificates

    # Server SSL Certificate and Key (The identity of this server)
    ssl_certificate     /etc/nginx/certs/server.crt;
    ssl_certificate_key /etc/nginx/certs/server.key;

    # Client Certificate Verification Configuration
    # This is the CA certificate used to sign the Client Certs
    ssl_client_certificate /etc/nginx/certs/rootCA.crt;
    
    # 'on' forces the user to present a valid certificate. 
    # If they don't, Nginx returns a 400 Bad Request error.
    ssl_verify_client on;

    # Standard SSL hardening (Optional but recommended)
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    # Root directory for the website content
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
        # Prevent caching of the text file so updates appear instantly
        location ~ /links.txt {
            add_header Cache-Control "no-store, no-cache, must-revalidate";
        }
    }

    # Guacamole Reverse Proxy Configuration
    location /guacamole/ {
        # REPLACE 'guacamole-host' with the actual IP or container name of your Guacamole server.
        # If running in the same docker-compose, use the service name (e.g., http://guacamole:8080/guacamole/)
        proxy_pass http://guacamole:8080/guacamole/;

        # Guacamole Requirement 1: Disable buffering for real-time streaming
        proxy_buffering off;

        # Guacamole Requirement 2: WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        # Forward client IP information
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Prevent Nginx from logging every single packet of the stream
        access_log off;
    }

    location /second/ {
    	# 1. The Trailing Slash Trick
    	# Note the slash at the end of the URL. 
    	# This strips "/console/" from the request before sending it to the destination.
    	proxy_pass https://host/";

    	# 2. Standard Headers
    	proxy_set_header Host $host;
    	proxy_set_header X-Real-IP $remote_addr;
    	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    	proxy_set_header X-Forwarded-Proto $scheme;

    	# 3. Fix Redirects
    	# If the upstream says "Go to /login", this changes it to "Go to /console/login"
    	proxy_redirect / /second/;
    
    	# 4. WebSocket Support (Crucial for modern JS apps)
    	proxy_http_version 1.1;
    	proxy_set_header Upgrade $http_upgrade;
    	proxy_set_header Connection "upgrade";

    	# 5. (Optional) HTML Content Rewriting
    	# Use this ONLY if the destination app uses absolute paths (e.g. src="/js/main.js") 
    	# and you cannot change the source code of that app.
    	# proxy_set_header Accept-Encoding ""; 
    	# sub_filter_once off;
    	# sub_filter_types text/html text/css text/javascript application/javascript;
    	# sub_filter 'href="/' 'href="/console/';
    	# sub_filter 'src="/' 'src="/console/';
    	# sub_filter 'action="/' 'action="/console/';
    }

    # Custom error page for authentication failure
    error_page 495 496 497 =403 /403error.html;
    error_page 404 /404error.html; 

    location = /403error.html {
        root   /usr/share/nginx/html;
        internal; 
    }

    location = /404error.html {
        root   /usr/share/nginx/html;
        internal;
    }
}
